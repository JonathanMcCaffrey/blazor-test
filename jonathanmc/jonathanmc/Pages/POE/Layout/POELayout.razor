@page "/poe/layout"

<h1>POE Hideout Layout</h1>

<p>
    Generate a blank Celestial Nebula Hideout layout, using one of the new ground tile decorations.
</p>

<p>Info: Since the POE layouts are in plain-text, it's easy enough to customly create and import the data, rather then manually add each item with the in-game editor.</p>

<p>Current count: @currentCount</p>

<pre>@layoutData</pre>

<button class="btn btn-primary" @onclick="GenerateSquareLayout">Click me</button>

@code {
    #region varibles
    int minX = 153;
    int minY = 559;
    int maxX = 560;
    int maxY = 153;

    int xOffset = 6;
    int yOffset = 6;


    int medSquareTileDimenions = 40;
    int largeCircleTileDimension = 30;//69;

    private int currentCount = 0;

    string defaultInfo = "";

    string layoutData = "";

    string tileUsed = "Grass Patch";//"Water Tile";
    string tileHash = "3856837925";//"1179014731";
    string tileVariant = "4";//"22";

    string sandTile = "Sand Ground";
    string sandTileHash = "1900098565";
    string sandTileVariant = "2";

    string medSquareVariant = "21";
    string largeSquareVariant = "22";
    string largeCircleVariant = "26";


    string defaultRotation = "0";
    string invertedRotation = "32768";
    // Rotation Data
    //Rot=49152
    //Rot=32768
    //Rot=16385
    //Rot

    string flippedValue = "1";

    //Min = { Hash=1179014731, X=153, Y=559, Rot=0, Flip=0, Var=22 }
    //Max = { Hash=1179014731, X=560, Y=153, Rot=0, Flip=0, Var=22 }


    #endregion

    private void GenerateSquareLayout()
    {
        #region main fill

        var random = new Random();
        var grassDifference = 24;



        for (int x = minX + xOffset; x <= maxX; x += largeCircleTileDimension)
        {
            for (int y = minY - yOffset; y >= maxY; y -= largeCircleTileDimension)
            {
                var xRand = random.NextDouble() * grassDifference;
                var yRand = random.NextDouble() * grassDifference;

                var newX = xRand + x;
                var newY = yRand + y;

                newX = newX < minX ? newX = minX : newX > maxX ? maxX: newX;
                newY = newY > minY ? newY = minY : newY < maxY ? maxY : newY;


                layoutData += $"{{{tileUsed}}} = {{ Hash={tileHash}, X={newX}, Y={newY}, Rot={defaultRotation}, Flip=0, Var={tileVariant} }}\n";
            }
        }
        #endregion

        #region flip to fill edges
        /* // Unused
        for (int x = minX; x < maxX; x += largeCircleTileDimension)
        {
            layoutData += $"{{{tileUsed}}} = {{ Hash={tileHash}, X={x}, Y={maxY}, Rot={defaultRotation}, Flip={flippedValue}, Var={largeSquareVariant} }}\n";
        }*/

        /*for (int y = minY; y < maxY; y += largeCircleTileDimension)
        {
            layoutData += $"{{{tileUsed}}} = {{ Hash={tileHash}, X={minX}, Y={y}, Rot={defaultRotation}, Flip={flippedValue}, Var={largeSquareVariant} }}\n";
        }*/
        #endregion
    }

    private void GenerateCircleLayout()
    {
        for (int x = minX; x < maxX; x += largeCircleTileDimension)
        {
            for (int y = minY; y < maxY; y += largeCircleTileDimension)
            {
                layoutData += $"{{{tileUsed}}} = {{ Hash={tileHash}, X={x}, Y={y}, Rot={defaultRotation}, Flip=0, Var={largeCircleVariant} }}\n";
            }
        }
    }
}
